# -*- coding: utf-8 -*-
"""Laberinto_v5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LyRUPDzqrxoUsbfkx6FbY8-Xq8dXXjEr
"""

import random
import math

def crear_laberinto(tamano):
    return [[0 for _ in range(tamano)] for _ in range(tamano)]

def pedir_coordenada(mensaje, tamano):
    while True:
        try:
            fila = int(input(f"{mensaje} fila (0-{tamano-1}): "))
            col = int(input(f"{mensaje} columna (0-{tamano-1}): "))
            # coordenadas dentro del rango
            if 0 <= fila < tamano and 0 <= col < tamano:
                return (fila, col)
            else:
                print("coordenadas fuera de rango.")
        except ValueError:
            print("entrada invalida. ingresa solo numeros.")

def colocar_obstaculos(laberinto, cantidad, inicio, fin, tamano):

    colocados = 0
    max_obstaculos = tamano * tamano - 2

    # limite de obstaculos
    if cantidad > max_obstaculos:
        print(f"maximo {max_obstaculos} obstaculos permitidos. usando {max_obstaculos}")
        cantidad = max_obstaculos

    while colocados < cantidad:
        # coordenadas aleatorias
        i = random.randint(0, tamano - 1)
        j = random.randint(0, tamano - 1)

        # celda este libre i f
        if laberinto[i][j] == 0 and (i, j) != inicio and (i, j) != fin:
            laberinto[i][j] = 1  # coloca obstaculo
            colocados += 1

def heuristica(a, b):
    #funcion h(n) del algoritmo a*
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

def vecinos(pos, tamano):
    direcciones = [(-1,0),(1,0),(0,-1),(0,1)]
    result = []

    for d in direcciones:
        ni, nj = pos[0] + d[0], pos[1] + d[1]
        # n posicion dentro del laberinto
        if 0 <= ni < tamano and 0 <= nj < tamano:
            result.append((ni, nj))
    return result

def reconstruir_camino(came_from, actual):

    camino = []
    # de final a inicio
    while actual in came_from:
        camino.append(actual)
        actual = came_from[actual]
    camino.reverse()
    return camino

def a_estrella(laberinto, inicio, fin, tamano):

    # nodos por explorar
    open_list = [inicio]
    # nodo anterior
    came_from = {}
    g_score = {inicio: 0}
    # costo total
    f_score = {inicio: heuristica(inicio, fin)}

    while open_list:
        # nodo mejor
        current = min(open_list, key=lambda x: f_score.get(x, float('inf')))
        # reconstruimos el camino
        if current == fin:
            return reconstruir_camino(came_from, current)
        open_list.remove(current)

        # explora nodo
        for vecino_pos in vecinos(current, tamano):
            if laberinto[vecino_pos[0]][vecino_pos[1]] == 1:
                continue
            tentative_g = g_score[current] + 1

            # camino mejor
            if tentative_g < g_score.get(vecino_pos, float('inf')):
                came_from[vecino_pos] = current
                g_score[vecino_pos] = tentative_g
                f_score[vecino_pos] = tentative_g + heuristica(vecino_pos, fin)
                if vecino_pos not in open_list:
                    open_list.append(vecino_pos)

    return None

def imprimir_laberinto(laberinto, tamano, camino=None, inicio=None, fin=None):

    for i in range(tamano):
        fila = ""
        for j in range(tamano):
            if (i,j) == inicio:
                fila += "I "
            elif (i,j) == fin:
                fila += "F "
            elif camino and (i,j) in camino:
                fila += "* "
            elif laberinto[i][j] == 1:
                fila += "# "
            else:
                fila += ". "
        print(fila)

def pedir_tamano():
    while True:
        try:
            tamano = int(input("ingresa el tamaño del laberinto (minimo 3): "))
            if tamano >= 3:
                return tamano
            else:
                print("el tamaño debe ser minimo 3x3")
        except ValueError:
            print("ingresa solo numeros.")

def main():
    # tamaño del laberinto
    tamano = pedir_tamano()
    laberinto = crear_laberinto(tamano)

    print(f"\nlaberinto de {tamano}x{tamano} creado")

    # coordenadas de inicio y fin
    inicio = pedir_coordenada("inicio", tamano)
    fin = pedir_coordenada("fin", tamano)

    # validacion
    if inicio == fin:
        print("error: el inicio y fin no pueden ser el mismo punto.")
        print("por favor ejecuta el programa de nuevo.")
        return

    # cantidad de obstaculos
    cant_obstaculos = int(input("cantidad de obstaculos: "))
    colocar_obstaculos(laberinto, cant_obstaculos, inicio, fin, tamano)

    print("\nbuscando camino...")
    camino = a_estrella(laberinto, inicio, fin, tamano)

    # resultado
    if camino:
        print(f"\ncamino encontrado! longitud: {len(camino)}")
        imprimir_laberinto(laberinto, tamano, camino, inicio, fin)
    else:
        print("\nno hay camino posible.")
        imprimir_laberinto(laberinto, tamano, None, inicio, fin)

if __name__ == "__main__":
    main()

